// js/exporter/exportConfluence.js

export function exportConfluence(doc) {
  const lines = [];

  const { meta, overview, endpoints, schemas, enums } = doc;

  // ==============================
  // ToC - Table of Contents
  // ==============================
  lines.push("h2. Table of Contents");
  lines.push("");

  doc.toc.sections.forEach((sec) => {
    lines.push(`* ${sec.title}`);
    if (sec.children && sec.children.length) {
      sec.children.forEach((child) => {
        lines.push(`** ${child.title}`);
      });
    }
  });
  lines.push("");

  // ==============================
  // Header
  // ==============================
  lines.push(`h1. ${meta.title}`);
  lines.push(`Version: ${meta.version}`);
  lines.push(`Generated: ${meta.generatedAt}`);
  lines.push("");

  // ==============================
  // Overview
  // ==============================
  lines.push("h2. Overview");
  lines.push(`* Total Schemas: ${overview.totalSchemas}`);
  lines.push(`* Total Endpoints: ${overview.totalEndpoints}`);
  lines.push("");
  lines.push("");

  // ==============================
  // Endpoints
  // ==============================
  lines.push("h2. Endpoints");
  lines.push("");
  if (!endpoints.length) {
    lines.push("_No endpoints defined._");
    lines.push("");
  } else {
    endpoints.forEach((ep, i) => {
      lines.push(`h3. ${ep.method.toUpperCase()} ${ep.path}`);
      if (ep.summary) lines.push(`* Summary: ${ep.summary}`);
      if (ep.description) lines.push(`* Description: ${ep.description}`);
      lines.push("");

      // Request Example
      if (ep.requestBodyExample) {
        lines.push("Example Request:");
        lines.push("{code}");
        lines.push(JSON.stringify(ep.requestBodyExample, null, 2));
        lines.push("{code}");
        lines.push("");
      }

      // Responses with examples
      if (ep.responses.length) {
        lines.push("Responses:");
        ep.responses.forEach((r) => {
          lines.push(`* ${r.status}: ${r.description || ""}`);
          if (r.example) {
            lines.push("{code}");
            lines.push(JSON.stringify(r.example, null, 2));
            lines.push("{code}");
          }
        });
      }

      lines.push("");
    });
  }

  lines.push("");

  // ==============================
  // Schemas
  // ==============================
  lines.push("h2. Schemas");
  lines.push("");
  schemas.forEach((s, i) => {
    lines.push(`h3. ${s.name}`);
    if (s.description) lines.push(`${s.description}`);
    lines.push("");

    if (s.properties.length) {
      lines.push("|| Property || Type || Required || Description ||");
      s.properties.forEach((p) => {
        lines.push(
          `| ${p.name} | ${p.type || ""} | ${p.required ? "yes" : "no"} | ${
            p.description || ""
          } |`
        );
      });
      lines.push("");
    }
    lines.push("");
  });

  // ==============================
  // Enums
  // ==============================
  lines.push("h2. Enums");
  lines.push("");
  if (!enums.length) {
    lines.push("_No enums defined._");
  } else {
    enums.forEach((en) => {
      lines.push(`h3. ${en.name}`);
      if (en.description) lines.push(en.description);
      lines.push("");
      en.values.forEach((v) => {
        lines.push(`* ${v.value}`);
      });
      lines.push("");
    });
  }

  // ==============================
  // Footer Attribution
  // ==============================
  lines.push("");
  lines.push("----");
  lines.push("Documentation generated by *Universal Schema Studio*");
  lines.push("https://schema.mumblebaj.xyz");

  return lines.join("\n");
}
